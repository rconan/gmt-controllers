//! # M1 hardpoints preprocessor
//!
//! The control system implements the pre-processing algorithm
//! for the M1 hardpoints trajectories
//!
//! This is imported from a Simulink model converted into C code.

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)]

/* automatically generated by rust-bindgen 0.69.4 */

pub const RT_PI: f64 = 3.141592653589793;
pub const RT_PIF: f64 = 3.1415927;
pub const RT_LN_10: f64 = 2.302585092994046;
pub const RT_LN_10F: f64 = 2.3025851;
pub const RT_LOG10E: f64 = 0.4342944819032518;
pub const RT_LOG10EF: f64 = 0.43429449;
pub const RT_E: f64 = 2.718281828459045;
pub const RT_EF: f64 = 2.7182817;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const UNINITIALIZED_ZCSIG: u32 = 3;
pub const NEG_ZCSIG: u32 = 2;
pub const POS_ZCSIG: u32 = 1;
pub const ZERO_ZCSIG: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub type RT_MODEL_m1hp_cpp_T = tag_RTM_m1hp_cpp_T;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type int8_T = ::std::os::raw::c_schar;
pub type uint8_T = ::std::os::raw::c_uchar;
pub type int16_T = ::std::os::raw::c_short;
pub type uint16_T = ::std::os::raw::c_ushort;
pub type int32_T = ::std::os::raw::c_int;
pub type uint32_T = ::std::os::raw::c_uint;
pub type int64_T = ::std::os::raw::c_long;
pub type uint64_T = ::std::os::raw::c_ulong;
pub type real32_T = f32;
pub type real64_T = f64;
pub type real_T = f64;
pub type time_T = f64;
pub type boolean_T = ::std::os::raw::c_uchar;
pub type int_T = ::std::os::raw::c_int;
pub type uint_T = ::std::os::raw::c_uint;
pub type ulong_T = ::std::os::raw::c_ulong;
pub type ulonglong_T = ::std::os::raw::c_ulonglong;
pub type char_T = ::std::os::raw::c_char;
pub type uchar_T = ::std::os::raw::c_uchar;
pub type byte_T = char_T;
pub type pointer_T = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub const ZCDirection_FALLING_ZERO_CROSSING: ZCDirection = -1;
pub const ZCDirection_ANY_ZERO_CROSSING: ZCDirection = 0;
pub const ZCDirection_RISING_ZERO_CROSSING: ZCDirection = 1;
pub type ZCDirection = ::std::os::raw::c_int;
pub type ZCSigState = uint8_T;
pub const ZCEventType_FALLING_ZCEVENT: ZCEventType = -1;
pub const ZCEventType_NO_ZCEVENT: ZCEventType = 0;
pub const ZCEventType_RISING_ZCEVENT: ZCEventType = 1;
pub type ZCEventType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DW_CoreSubsys_m1hp_cpp_T {
    pub BesselfilterAcc_DSTATE: [real_T; 4usize],
    pub BesselfilterPos_DSTATE: [real_T; 4usize],
    pub BesselfilterVel_DSTATE: [real_T; 4usize],
}
#[test]
fn bindgen_test_layout_DW_CoreSubsys_m1hp_cpp_T() {
    const UNINIT: ::std::mem::MaybeUninit<DW_CoreSubsys_m1hp_cpp_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DW_CoreSubsys_m1hp_cpp_T>(),
        96usize,
        concat!("Size of: ", stringify!(DW_CoreSubsys_m1hp_cpp_T))
    );
    assert_eq!(
        ::std::mem::align_of::<DW_CoreSubsys_m1hp_cpp_T>(),
        8usize,
        concat!("Alignment of ", stringify!(DW_CoreSubsys_m1hp_cpp_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BesselfilterAcc_DSTATE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_T),
            "::",
            stringify!(BesselfilterAcc_DSTATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BesselfilterPos_DSTATE) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_T),
            "::",
            stringify!(BesselfilterPos_DSTATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BesselfilterVel_DSTATE) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_T),
            "::",
            stringify!(BesselfilterVel_DSTATE)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DW_CoreSubsys_m1hp_cpp_f_T {
    pub acc_merge: real_T,
}
#[test]
fn bindgen_test_layout_DW_CoreSubsys_m1hp_cpp_f_T() {
    const UNINIT: ::std::mem::MaybeUninit<DW_CoreSubsys_m1hp_cpp_f_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DW_CoreSubsys_m1hp_cpp_f_T>(),
        8usize,
        concat!("Size of: ", stringify!(DW_CoreSubsys_m1hp_cpp_f_T))
    );
    assert_eq!(
        ::std::mem::align_of::<DW_CoreSubsys_m1hp_cpp_f_T>(),
        8usize,
        concat!("Alignment of ", stringify!(DW_CoreSubsys_m1hp_cpp_f_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acc_merge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_f_T),
            "::",
            stringify!(acc_merge)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DW_CoreSubsys_m1hp_cpp_fw_T {
    pub DiscreteTimeIntegrator: real_T,
    pub x0_in: real_T,
    pub v0_in: real_T,
    pub DiscreteTimeIntegrator_DSTATE: real_T,
    pub DelayInput1_DSTATE: real_T,
    pub TmpLatchAtTriggeredSubsystemInp: real_T,
    pub TmpLatchAtTriggeredSubsystemI_e: real_T,
}
#[test]
fn bindgen_test_layout_DW_CoreSubsys_m1hp_cpp_fw_T() {
    const UNINIT: ::std::mem::MaybeUninit<DW_CoreSubsys_m1hp_cpp_fw_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DW_CoreSubsys_m1hp_cpp_fw_T>(),
        56usize,
        concat!("Size of: ", stringify!(DW_CoreSubsys_m1hp_cpp_fw_T))
    );
    assert_eq!(
        ::std::mem::align_of::<DW_CoreSubsys_m1hp_cpp_fw_T>(),
        8usize,
        concat!("Alignment of ", stringify!(DW_CoreSubsys_m1hp_cpp_fw_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DiscreteTimeIntegrator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_fw_T),
            "::",
            stringify!(DiscreteTimeIntegrator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x0_in) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_fw_T),
            "::",
            stringify!(x0_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v0_in) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_fw_T),
            "::",
            stringify!(v0_in)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DiscreteTimeIntegrator_DSTATE) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_fw_T),
            "::",
            stringify!(DiscreteTimeIntegrator_DSTATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DelayInput1_DSTATE) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_fw_T),
            "::",
            stringify!(DelayInput1_DSTATE)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TmpLatchAtTriggeredSubsystemInp) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_fw_T),
            "::",
            stringify!(TmpLatchAtTriggeredSubsystemInp)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TmpLatchAtTriggeredSubsystemI_e) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_CoreSubsys_m1hp_cpp_fw_T),
            "::",
            stringify!(TmpLatchAtTriggeredSubsystemI_e)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZCE_CoreSubsys_m1hp_cpp_fe_T {
    pub TriggeredSubsystem_Trig_ZCE_c: ZCSigState,
}
#[test]
fn bindgen_test_layout_ZCE_CoreSubsys_m1hp_cpp_fe_T() {
    const UNINIT: ::std::mem::MaybeUninit<ZCE_CoreSubsys_m1hp_cpp_fe_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZCE_CoreSubsys_m1hp_cpp_fe_T>(),
        1usize,
        concat!("Size of: ", stringify!(ZCE_CoreSubsys_m1hp_cpp_fe_T))
    );
    assert_eq!(
        ::std::mem::align_of::<ZCE_CoreSubsys_m1hp_cpp_fe_T>(),
        1usize,
        concat!("Alignment of ", stringify!(ZCE_CoreSubsys_m1hp_cpp_fe_T))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TriggeredSubsystem_Trig_ZCE_c) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZCE_CoreSubsys_m1hp_cpp_fe_T),
            "::",
            stringify!(TriggeredSubsystem_Trig_ZCE_c)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DW_m1hp_cpp_T {
    pub CoreSubsys_pn: [DW_CoreSubsys_m1hp_cpp_fw_T; 6usize],
    pub CoreSubsys_p: [DW_CoreSubsys_m1hp_cpp_f_T; 6usize],
    pub CoreSubsys: [DW_CoreSubsys_m1hp_cpp_T; 6usize],
    pub Add: [real_T; 6usize],
    pub Sub: [real_T; 6usize],
    pub ImpAsg_InsertedFor_a_l_at_inpor: [real_T; 6usize],
    pub ImpAsg_InsertedFor_multi_ax_acc: [real_T; 6usize],
    pub TmpLatchAtTriggeredSubsystemInp: [real_T; 6usize],
    pub TmpLatchAtTriggeredSubsystemI_e: [real_T; 6usize],
    pub IndexVector: uint32_T,
    pub IndexVector1: uint32_T,
    pub IndexVector2: uint32_T,
    pub Dk_merge: uint32_T,
    pub UnitDelay_DSTATE: uint32_T,
    pub ResettableDelay_DSTATE: uint32_T,
    pub Compare: [boolean_T; 6usize],
}
#[test]
fn bindgen_test_layout_DW_m1hp_cpp_T() {
    const UNINIT: ::std::mem::MaybeUninit<DW_m1hp_cpp_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DW_m1hp_cpp_T>(),
        1280usize,
        concat!("Size of: ", stringify!(DW_m1hp_cpp_T))
    );
    assert_eq!(
        ::std::mem::align_of::<DW_m1hp_cpp_T>(),
        8usize,
        concat!("Alignment of ", stringify!(DW_m1hp_cpp_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CoreSubsys_pn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(CoreSubsys_pn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CoreSubsys_p) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(CoreSubsys_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CoreSubsys) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(CoreSubsys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Add) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(Add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sub) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(Sub)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ImpAsg_InsertedFor_a_l_at_inpor) as usize - ptr as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(ImpAsg_InsertedFor_a_l_at_inpor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ImpAsg_InsertedFor_multi_ax_acc) as usize - ptr as usize
        },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(ImpAsg_InsertedFor_multi_ax_acc)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TmpLatchAtTriggeredSubsystemInp) as usize - ptr as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(TmpLatchAtTriggeredSubsystemInp)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TmpLatchAtTriggeredSubsystemI_e) as usize - ptr as usize
        },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(TmpLatchAtTriggeredSubsystemI_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexVector) as usize - ptr as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(IndexVector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexVector1) as usize - ptr as usize },
        1252usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(IndexVector1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexVector2) as usize - ptr as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(IndexVector2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dk_merge) as usize - ptr as usize },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(Dk_merge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnitDelay_DSTATE) as usize - ptr as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(UnitDelay_DSTATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResettableDelay_DSTATE) as usize - ptr as usize },
        1268usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(ResettableDelay_DSTATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Compare) as usize - ptr as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(DW_m1hp_cpp_T),
            "::",
            stringify!(Compare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrevZCX_m1hp_cpp_T {
    pub ResettableDelay_Reset_ZCE: ZCSigState,
    pub TriggeredSubsystem_Trig_ZCE: ZCSigState,
    pub CoreSubsys_pn: [ZCE_CoreSubsys_m1hp_cpp_fe_T; 6usize],
}
#[test]
fn bindgen_test_layout_PrevZCX_m1hp_cpp_T() {
    const UNINIT: ::std::mem::MaybeUninit<PrevZCX_m1hp_cpp_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PrevZCX_m1hp_cpp_T>(),
        8usize,
        concat!("Size of: ", stringify!(PrevZCX_m1hp_cpp_T))
    );
    assert_eq!(
        ::std::mem::align_of::<PrevZCX_m1hp_cpp_T>(),
        1usize,
        concat!("Alignment of ", stringify!(PrevZCX_m1hp_cpp_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResettableDelay_Reset_ZCE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PrevZCX_m1hp_cpp_T),
            "::",
            stringify!(ResettableDelay_Reset_ZCE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TriggeredSubsystem_Trig_ZCE) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PrevZCX_m1hp_cpp_T),
            "::",
            stringify!(TriggeredSubsystem_Trig_ZCE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CoreSubsys_pn) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PrevZCX_m1hp_cpp_T),
            "::",
            stringify!(CoreSubsys_pn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtU_m1hp_cpp_T {
    pub x_target: [real_T; 6usize],
    pub v_target: [real_T; 6usize],
}
#[test]
fn bindgen_test_layout_ExtU_m1hp_cpp_T() {
    const UNINIT: ::std::mem::MaybeUninit<ExtU_m1hp_cpp_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ExtU_m1hp_cpp_T>(),
        96usize,
        concat!("Size of: ", stringify!(ExtU_m1hp_cpp_T))
    );
    assert_eq!(
        ::std::mem::align_of::<ExtU_m1hp_cpp_T>(),
        8usize,
        concat!("Alignment of ", stringify!(ExtU_m1hp_cpp_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtU_m1hp_cpp_T),
            "::",
            stringify!(x_target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_target) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtU_m1hp_cpp_T),
            "::",
            stringify!(v_target)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtY_m1hp_cpp_T {
    pub pos_d: [real_T; 6usize],
    pub vel_d: [real_T; 6usize],
    pub acc_d: [real_T; 6usize],
}
#[test]
fn bindgen_test_layout_ExtY_m1hp_cpp_T() {
    const UNINIT: ::std::mem::MaybeUninit<ExtY_m1hp_cpp_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ExtY_m1hp_cpp_T>(),
        144usize,
        concat!("Size of: ", stringify!(ExtY_m1hp_cpp_T))
    );
    assert_eq!(
        ::std::mem::align_of::<ExtY_m1hp_cpp_T>(),
        8usize,
        concat!("Alignment of ", stringify!(ExtY_m1hp_cpp_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos_d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtY_m1hp_cpp_T),
            "::",
            stringify!(pos_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vel_d) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtY_m1hp_cpp_T),
            "::",
            stringify!(vel_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acc_d) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtY_m1hp_cpp_T),
            "::",
            stringify!(acc_d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_RTM_m1hp_cpp_T {
    pub prevZCSigState: *mut PrevZCX_m1hp_cpp_T,
    pub dwork: *mut DW_m1hp_cpp_T,
}
#[test]
fn bindgen_test_layout_tag_RTM_m1hp_cpp_T() {
    const UNINIT: ::std::mem::MaybeUninit<tag_RTM_m1hp_cpp_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tag_RTM_m1hp_cpp_T>(),
        16usize,
        concat!("Size of: ", stringify!(tag_RTM_m1hp_cpp_T))
    );
    assert_eq!(
        ::std::mem::align_of::<tag_RTM_m1hp_cpp_T>(),
        8usize,
        concat!("Alignment of ", stringify!(tag_RTM_m1hp_cpp_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prevZCSigState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tag_RTM_m1hp_cpp_T),
            "::",
            stringify!(prevZCSigState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwork) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tag_RTM_m1hp_cpp_T),
            "::",
            stringify!(dwork)
        )
    );
}
extern "C" {
    pub fn m1hp_cpp_initialize(m1hp_cpp_M: *mut RT_MODEL_m1hp_cpp_T);
}
extern "C" {
    pub fn m1hp_cpp_step(
        m1hp_cpp_M: *mut RT_MODEL_m1hp_cpp_T,
        m1hp_cpp_U: *mut ExtU_m1hp_cpp_T,
        m1hp_cpp_Y: *mut ExtY_m1hp_cpp_T,
    );
}
extern "C" {
    pub fn m1hp_cpp_terminate(m1hp_cpp_M: *mut RT_MODEL_m1hp_cpp_T);
}
#[link(name = "gmt_m1_ctrl_hardpoints_preprocessor")]
extern "C" {
    pub static mut k_cmd: uint32_T;
}
extern "C" {
    pub fn m1hp_cp_IfActionSubsystem4_Init(rty_ac0: *mut real_T);
}
extern "C" {
    pub fn m1hp_cpp_IfActionSubsystem4(rty_ac0: *mut real_T);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}

/// Rust binder to Simulink C controller wrapper
#[allow(dead_code)]
pub type HardpointsPreprocessor = m1hp_cpp;

/// Simulink controller wrapper
#[derive(Clone, Copy, Debug, Default, ::serde::Serialize, ::serde::Deserialize)]
pub struct m1hp_cpp {
    // Inputs Simulink structure
    pub inputs: ExtU_m1hp_cpp_T,
    // Outputs Simulink structure
    pub outputs: ExtY_m1hp_cpp_T,
    rs_k_cmd: u32,
    states: RealTimeData,
}

impl Default for DW_CoreSubsys_m1hp_cpp_T {
    fn default() -> Self {
        Self {
            BesselfilterAcc_DSTATE: [Default::default(); 4],
            BesselfilterPos_DSTATE: [Default::default(); 4],
            BesselfilterVel_DSTATE: [Default::default(); 4],
        }
    }
}

impl Default for DW_CoreSubsys_m1hp_cpp_f_T {
    fn default() -> Self {
        Self {
            acc_merge: Default::default(),
        }
    }
}

impl Default for DW_CoreSubsys_m1hp_cpp_fw_T {
    fn default() -> Self {
        Self {
            DiscreteTimeIntegrator: Default::default(),
            x0_in: Default::default(),
            v0_in: Default::default(),
            DiscreteTimeIntegrator_DSTATE: Default::default(),
            DelayInput1_DSTATE: Default::default(),
            TmpLatchAtTriggeredSubsystemInp: Default::default(),
            TmpLatchAtTriggeredSubsystemI_e: Default::default(),
        }
    }
}

impl Default for ZCE_CoreSubsys_m1hp_cpp_fe_T {
    fn default() -> Self {
        Self {
            TriggeredSubsystem_Trig_ZCE_c: Default::default(),
        }
    }
}

impl Default for DW_m1hp_cpp_T {
    fn default() -> Self {
        Self {
            CoreSubsys_pn: [Default::default(); 6],
            CoreSubsys_p: [Default::default(); 6],
            CoreSubsys: [Default::default(); 6],
            Add: [Default::default(); 6],
            Sub: [Default::default(); 6],
            ImpAsg_InsertedFor_a_l_at_inpor: [Default::default(); 6],
            ImpAsg_InsertedFor_multi_ax_acc: [Default::default(); 6],
            TmpLatchAtTriggeredSubsystemInp: [Default::default(); 6],
            TmpLatchAtTriggeredSubsystemI_e: [Default::default(); 6],
            IndexVector: Default::default(),
            IndexVector1: Default::default(),
            IndexVector2: Default::default(),
            Dk_merge: Default::default(),
            UnitDelay_DSTATE: Default::default(),
            ResettableDelay_DSTATE: Default::default(),
            Compare: [Default::default(); 6],
        }
    }
}

impl Default for PrevZCX_m1hp_cpp_T {
    fn default() -> Self {
        Self {
            ResettableDelay_Reset_ZCE: Default::default(),
            TriggeredSubsystem_Trig_ZCE: Default::default(),
            CoreSubsys_pn: [Default::default(); 6],
        }
    }
}

impl Default for ExtU_m1hp_cpp_T {
    fn default() -> Self {
        Self {
            x_target: [Default::default(); 6],
            v_target: [Default::default(); 6],
        }
    }
}

impl Default for ExtY_m1hp_cpp_T {
    fn default() -> Self {
        Self {
            pos_d: [Default::default(); 6],
            vel_d: [Default::default(); 6],
            acc_d: [Default::default(); 6],
        }
    }
}

impl m1hp_cpp {
    /// Creates a new controller
    pub fn new(rs_k_cmd: u32) -> Self {
        let mut this: Self = Default::default();

        this.rs_k_cmd = rs_k_cmd;
        unsafe {
            k_cmd = this.rs_k_cmd;
        }

        let mut data: RT_MODEL_m1hp_cpp_T = this.states.as_mut();
        unsafe { m1hp_cpp_initialize(&mut data as *mut _) }
        this
    }
    /// Steps the controller
    pub fn step(&mut self) {
        let mut data: RT_MODEL_m1hp_cpp_T = self.states.as_mut();
        unsafe {
            m1hp_cpp_step(
                &mut data as *mut _,
                &mut self.inputs as *mut _,
                &mut self.outputs as *mut _,
            )
        }
    }
}

impl ::serde::ser::Serialize for DW_CoreSubsys_m1hp_cpp_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("DW_CoreSubsys_m1hp_cpp_T", 3)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "BesselfilterAcc_DSTATE",
            &Vec::from(&self.BesselfilterAcc_DSTATE),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "BesselfilterPos_DSTATE",
            &Vec::from(&self.BesselfilterPos_DSTATE),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "BesselfilterVel_DSTATE",
            &Vec::from(&self.BesselfilterVel_DSTATE),
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DW_CoreSubsys_m1hp_cpp_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &[
            "BesselfilterAcc_DSTATE",
            "BesselfilterPos_DSTATE",
            "BesselfilterVel_DSTATE",
        ];

        enum Field {
            BesselfilterAcc_DSTATE,
            BesselfilterPos_DSTATE,
            BesselfilterVel_DSTATE,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "BesselfilterAcc_DSTATE" => Ok(Field::BesselfilterAcc_DSTATE),
                            "BesselfilterPos_DSTATE" => Ok(Field::BesselfilterPos_DSTATE),
                            "BesselfilterVel_DSTATE" => Ok(Field::BesselfilterVel_DSTATE),
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = DW_CoreSubsys_m1hp_cpp_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DW_CoreSubsys_m1hp_cpp_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let BesselfilterAcc_DSTATE: [f64; 4] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let BesselfilterPos_DSTATE: [f64; 4] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(4, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let BesselfilterVel_DSTATE: [f64; 4] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(8, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(DW_CoreSubsys_m1hp_cpp_T {
                    BesselfilterAcc_DSTATE,
                    BesselfilterPos_DSTATE,
                    BesselfilterVel_DSTATE,
                })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut BesselfilterAcc_DSTATE = None;
                let mut BesselfilterPos_DSTATE = None;
                let mut BesselfilterVel_DSTATE = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::BesselfilterAcc_DSTATE => {
                            if BesselfilterAcc_DSTATE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "BesselfilterAcc_DSTATE",
                                ));
                            }
                            BesselfilterAcc_DSTATE = Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::BesselfilterPos_DSTATE => {
                            if BesselfilterPos_DSTATE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "BesselfilterPos_DSTATE",
                                ));
                            }
                            BesselfilterPos_DSTATE = Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::BesselfilterVel_DSTATE => {
                            if BesselfilterVel_DSTATE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "BesselfilterVel_DSTATE",
                                ));
                            }
                            BesselfilterVel_DSTATE = Some(map.next_value::<Vec<real_T>>()?);
                        }
                    }
                }

                let BesselfilterAcc_DSTATE: [f64; 4] = BesselfilterAcc_DSTATE
                    .ok_or_else(|| ::serde::de::Error::missing_field("BesselfilterAcc_DSTATE"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let BesselfilterPos_DSTATE: [f64; 4] = BesselfilterPos_DSTATE
                    .ok_or_else(|| ::serde::de::Error::missing_field("BesselfilterPos_DSTATE"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let BesselfilterVel_DSTATE: [f64; 4] = BesselfilterVel_DSTATE
                    .ok_or_else(|| ::serde::de::Error::missing_field("BesselfilterVel_DSTATE"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(DW_CoreSubsys_m1hp_cpp_T {
                    BesselfilterAcc_DSTATE,
                    BesselfilterPos_DSTATE,
                    BesselfilterVel_DSTATE,
                })
            }
        }
        deserializer.deserialize_struct("DW_CoreSubsys_m1hp_cpp_T", FIELDS, SimulinkVisitor)
    }
}

impl ::serde::ser::Serialize for DW_CoreSubsys_m1hp_cpp_f_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("DW_CoreSubsys_m1hp_cpp_f_T", 1)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "acc_merge",
            &self.acc_merge,
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DW_CoreSubsys_m1hp_cpp_f_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &["acc_merge"];

        enum Field {
            acc_merge,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "acc_merge" => Ok(Field::acc_merge),
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = DW_CoreSubsys_m1hp_cpp_f_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DW_CoreSubsys_m1hp_cpp_f_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let acc_merge = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(DW_CoreSubsys_m1hp_cpp_f_T { acc_merge })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut acc_merge = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::acc_merge => {
                            if acc_merge.is_some() {
                                return Err(::serde::de::Error::duplicate_field("acc_merge"));
                            }
                            acc_merge = Some(map.next_value::<real_T>()?);
                        }
                    }
                }

                let acc_merge =
                    acc_merge.ok_or_else(|| ::serde::de::Error::missing_field("acc_merge"))?;

                Ok(DW_CoreSubsys_m1hp_cpp_f_T { acc_merge })
            }
        }
        deserializer.deserialize_struct("DW_CoreSubsys_m1hp_cpp_f_T", FIELDS, SimulinkVisitor)
    }
}

impl ::serde::ser::Serialize for DW_CoreSubsys_m1hp_cpp_fw_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("DW_CoreSubsys_m1hp_cpp_fw_T", 7)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "DiscreteTimeIntegrator",
            &self.DiscreteTimeIntegrator,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(&mut serde_state, "x0_in", &self.x0_in)?;

        ::serde::ser::SerializeStruct::serialize_field(&mut serde_state, "v0_in", &self.v0_in)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "DiscreteTimeIntegrator_DSTATE",
            &self.DiscreteTimeIntegrator_DSTATE,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "DelayInput1_DSTATE",
            &self.DelayInput1_DSTATE,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "TmpLatchAtTriggeredSubsystemInp",
            &self.TmpLatchAtTriggeredSubsystemInp,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "TmpLatchAtTriggeredSubsystemI_e",
            &self.TmpLatchAtTriggeredSubsystemI_e,
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DW_CoreSubsys_m1hp_cpp_fw_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &[
            "DiscreteTimeIntegrator",
            "x0_in",
            "v0_in",
            "DiscreteTimeIntegrator_DSTATE",
            "DelayInput1_DSTATE",
            "TmpLatchAtTriggeredSubsystemInp",
            "TmpLatchAtTriggeredSubsystemI_e",
        ];

        enum Field {
            DiscreteTimeIntegrator,
            x0_in,
            v0_in,
            DiscreteTimeIntegrator_DSTATE,
            DelayInput1_DSTATE,
            TmpLatchAtTriggeredSubsystemInp,
            TmpLatchAtTriggeredSubsystemI_e,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "DiscreteTimeIntegrator" => Ok(Field::DiscreteTimeIntegrator),
                            "x0_in" => Ok(Field::x0_in),
                            "v0_in" => Ok(Field::v0_in),
                            "DiscreteTimeIntegrator_DSTATE" => {
                                Ok(Field::DiscreteTimeIntegrator_DSTATE)
                            }
                            "DelayInput1_DSTATE" => Ok(Field::DelayInput1_DSTATE),
                            "TmpLatchAtTriggeredSubsystemInp" => {
                                Ok(Field::TmpLatchAtTriggeredSubsystemInp)
                            }
                            "TmpLatchAtTriggeredSubsystemI_e" => {
                                Ok(Field::TmpLatchAtTriggeredSubsystemI_e)
                            }
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = DW_CoreSubsys_m1hp_cpp_fw_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DW_CoreSubsys_m1hp_cpp_fw_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let DiscreteTimeIntegrator = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let x0_in = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(1, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let v0_in = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(2, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let DiscreteTimeIntegrator_DSTATE = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(3, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let DelayInput1_DSTATE = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(4, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let TmpLatchAtTriggeredSubsystemInp = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(5, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let TmpLatchAtTriggeredSubsystemI_e = seq
                    .next_element::<f64>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(6, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(DW_CoreSubsys_m1hp_cpp_fw_T {
                    DiscreteTimeIntegrator,
                    x0_in,
                    v0_in,
                    DiscreteTimeIntegrator_DSTATE,
                    DelayInput1_DSTATE,
                    TmpLatchAtTriggeredSubsystemInp,
                    TmpLatchAtTriggeredSubsystemI_e,
                })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut DiscreteTimeIntegrator = None;
                let mut x0_in = None;
                let mut v0_in = None;
                let mut DiscreteTimeIntegrator_DSTATE = None;
                let mut DelayInput1_DSTATE = None;
                let mut TmpLatchAtTriggeredSubsystemInp = None;
                let mut TmpLatchAtTriggeredSubsystemI_e = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::DiscreteTimeIntegrator => {
                            if DiscreteTimeIntegrator.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "DiscreteTimeIntegrator",
                                ));
                            }
                            DiscreteTimeIntegrator = Some(map.next_value::<real_T>()?);
                        }

                        Field::x0_in => {
                            if x0_in.is_some() {
                                return Err(::serde::de::Error::duplicate_field("x0_in"));
                            }
                            x0_in = Some(map.next_value::<real_T>()?);
                        }

                        Field::v0_in => {
                            if v0_in.is_some() {
                                return Err(::serde::de::Error::duplicate_field("v0_in"));
                            }
                            v0_in = Some(map.next_value::<real_T>()?);
                        }

                        Field::DiscreteTimeIntegrator_DSTATE => {
                            if DiscreteTimeIntegrator_DSTATE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "DiscreteTimeIntegrator_DSTATE",
                                ));
                            }
                            DiscreteTimeIntegrator_DSTATE = Some(map.next_value::<real_T>()?);
                        }

                        Field::DelayInput1_DSTATE => {
                            if DelayInput1_DSTATE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "DelayInput1_DSTATE",
                                ));
                            }
                            DelayInput1_DSTATE = Some(map.next_value::<real_T>()?);
                        }

                        Field::TmpLatchAtTriggeredSubsystemInp => {
                            if TmpLatchAtTriggeredSubsystemInp.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "TmpLatchAtTriggeredSubsystemInp",
                                ));
                            }
                            TmpLatchAtTriggeredSubsystemInp = Some(map.next_value::<real_T>()?);
                        }

                        Field::TmpLatchAtTriggeredSubsystemI_e => {
                            if TmpLatchAtTriggeredSubsystemI_e.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "TmpLatchAtTriggeredSubsystemI_e",
                                ));
                            }
                            TmpLatchAtTriggeredSubsystemI_e = Some(map.next_value::<real_T>()?);
                        }
                    }
                }

                let DiscreteTimeIntegrator = DiscreteTimeIntegrator
                    .ok_or_else(|| ::serde::de::Error::missing_field("DiscreteTimeIntegrator"))?;

                let x0_in = x0_in.ok_or_else(|| ::serde::de::Error::missing_field("x0_in"))?;

                let v0_in = v0_in.ok_or_else(|| ::serde::de::Error::missing_field("v0_in"))?;

                let DiscreteTimeIntegrator_DSTATE =
                    DiscreteTimeIntegrator_DSTATE.ok_or_else(|| {
                        ::serde::de::Error::missing_field("DiscreteTimeIntegrator_DSTATE")
                    })?;

                let DelayInput1_DSTATE = DelayInput1_DSTATE
                    .ok_or_else(|| ::serde::de::Error::missing_field("DelayInput1_DSTATE"))?;

                let TmpLatchAtTriggeredSubsystemInp =
                    TmpLatchAtTriggeredSubsystemInp.ok_or_else(|| {
                        ::serde::de::Error::missing_field("TmpLatchAtTriggeredSubsystemInp")
                    })?;

                let TmpLatchAtTriggeredSubsystemI_e =
                    TmpLatchAtTriggeredSubsystemI_e.ok_or_else(|| {
                        ::serde::de::Error::missing_field("TmpLatchAtTriggeredSubsystemI_e")
                    })?;

                Ok(DW_CoreSubsys_m1hp_cpp_fw_T {
                    DiscreteTimeIntegrator,
                    x0_in,
                    v0_in,
                    DiscreteTimeIntegrator_DSTATE,
                    DelayInput1_DSTATE,
                    TmpLatchAtTriggeredSubsystemInp,
                    TmpLatchAtTriggeredSubsystemI_e,
                })
            }
        }
        deserializer.deserialize_struct("DW_CoreSubsys_m1hp_cpp_fw_T", FIELDS, SimulinkVisitor)
    }
}

impl ::serde::ser::Serialize for ZCE_CoreSubsys_m1hp_cpp_fe_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("ZCE_CoreSubsys_m1hp_cpp_fe_T", 1)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "TriggeredSubsystem_Trig_ZCE_c",
            &self.TriggeredSubsystem_Trig_ZCE_c,
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ZCE_CoreSubsys_m1hp_cpp_fe_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &["TriggeredSubsystem_Trig_ZCE_c"];

        enum Field {
            TriggeredSubsystem_Trig_ZCE_c,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "TriggeredSubsystem_Trig_ZCE_c" => {
                                Ok(Field::TriggeredSubsystem_Trig_ZCE_c)
                            }
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = ZCE_CoreSubsys_m1hp_cpp_fe_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZCE_CoreSubsys_m1hp_cpp_fe_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let TriggeredSubsystem_Trig_ZCE_c = seq
                    .next_element::<ZCSigState>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(ZCE_CoreSubsys_m1hp_cpp_fe_T {
                    TriggeredSubsystem_Trig_ZCE_c,
                })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut TriggeredSubsystem_Trig_ZCE_c = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::TriggeredSubsystem_Trig_ZCE_c => {
                            if TriggeredSubsystem_Trig_ZCE_c.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "TriggeredSubsystem_Trig_ZCE_c",
                                ));
                            }
                            TriggeredSubsystem_Trig_ZCE_c = Some(map.next_value::<ZCSigState>()?);
                        }
                    }
                }

                let TriggeredSubsystem_Trig_ZCE_c =
                    TriggeredSubsystem_Trig_ZCE_c.ok_or_else(|| {
                        ::serde::de::Error::missing_field("TriggeredSubsystem_Trig_ZCE_c")
                    })?;

                Ok(ZCE_CoreSubsys_m1hp_cpp_fe_T {
                    TriggeredSubsystem_Trig_ZCE_c,
                })
            }
        }
        deserializer.deserialize_struct("ZCE_CoreSubsys_m1hp_cpp_fe_T", FIELDS, SimulinkVisitor)
    }
}

impl ::serde::ser::Serialize for DW_m1hp_cpp_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("DW_m1hp_cpp_T", 16)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "CoreSubsys_pn",
            &Vec::from(&self.CoreSubsys_pn),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "CoreSubsys_p",
            &Vec::from(&self.CoreSubsys_p),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "CoreSubsys",
            &Vec::from(&self.CoreSubsys),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "Add",
            &Vec::from(&self.Add),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "Sub",
            &Vec::from(&self.Sub),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "ImpAsg_InsertedFor_a_l_at_inpor",
            &Vec::from(&self.ImpAsg_InsertedFor_a_l_at_inpor),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "ImpAsg_InsertedFor_multi_ax_acc",
            &Vec::from(&self.ImpAsg_InsertedFor_multi_ax_acc),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "TmpLatchAtTriggeredSubsystemInp",
            &Vec::from(&self.TmpLatchAtTriggeredSubsystemInp),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "TmpLatchAtTriggeredSubsystemI_e",
            &Vec::from(&self.TmpLatchAtTriggeredSubsystemI_e),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "IndexVector",
            &self.IndexVector,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "IndexVector1",
            &self.IndexVector1,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "IndexVector2",
            &self.IndexVector2,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "Dk_merge",
            &self.Dk_merge,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "UnitDelay_DSTATE",
            &self.UnitDelay_DSTATE,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "ResettableDelay_DSTATE",
            &self.ResettableDelay_DSTATE,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "Compare",
            &Vec::from(&self.Compare),
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DW_m1hp_cpp_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &[
            "CoreSubsys_pn",
            "CoreSubsys_p",
            "CoreSubsys",
            "Add",
            "Sub",
            "ImpAsg_InsertedFor_a_l_at_inpor",
            "ImpAsg_InsertedFor_multi_ax_acc",
            "TmpLatchAtTriggeredSubsystemInp",
            "TmpLatchAtTriggeredSubsystemI_e",
            "IndexVector",
            "IndexVector1",
            "IndexVector2",
            "Dk_merge",
            "UnitDelay_DSTATE",
            "ResettableDelay_DSTATE",
            "Compare",
        ];

        enum Field {
            CoreSubsys_pn,
            CoreSubsys_p,
            CoreSubsys,
            Add,
            Sub,
            ImpAsg_InsertedFor_a_l_at_inpor,
            ImpAsg_InsertedFor_multi_ax_acc,
            TmpLatchAtTriggeredSubsystemInp,
            TmpLatchAtTriggeredSubsystemI_e,
            IndexVector,
            IndexVector1,
            IndexVector2,
            Dk_merge,
            UnitDelay_DSTATE,
            ResettableDelay_DSTATE,
            Compare,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "CoreSubsys_pn" => Ok(Field::CoreSubsys_pn),
                            "CoreSubsys_p" => Ok(Field::CoreSubsys_p),
                            "CoreSubsys" => Ok(Field::CoreSubsys),
                            "Add" => Ok(Field::Add),
                            "Sub" => Ok(Field::Sub),
                            "ImpAsg_InsertedFor_a_l_at_inpor" => {
                                Ok(Field::ImpAsg_InsertedFor_a_l_at_inpor)
                            }
                            "ImpAsg_InsertedFor_multi_ax_acc" => {
                                Ok(Field::ImpAsg_InsertedFor_multi_ax_acc)
                            }
                            "TmpLatchAtTriggeredSubsystemInp" => {
                                Ok(Field::TmpLatchAtTriggeredSubsystemInp)
                            }
                            "TmpLatchAtTriggeredSubsystemI_e" => {
                                Ok(Field::TmpLatchAtTriggeredSubsystemI_e)
                            }
                            "IndexVector" => Ok(Field::IndexVector),
                            "IndexVector1" => Ok(Field::IndexVector1),
                            "IndexVector2" => Ok(Field::IndexVector2),
                            "Dk_merge" => Ok(Field::Dk_merge),
                            "UnitDelay_DSTATE" => Ok(Field::UnitDelay_DSTATE),
                            "ResettableDelay_DSTATE" => Ok(Field::ResettableDelay_DSTATE),
                            "Compare" => Ok(Field::Compare),
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = DW_m1hp_cpp_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DW_m1hp_cpp_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let CoreSubsys_pn: [DW_CoreSubsys_m1hp_cpp_fw_T; 6] = seq
                    .next_element::<Vec<DW_CoreSubsys_m1hp_cpp_fw_T>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let CoreSubsys_p: [DW_CoreSubsys_m1hp_cpp_f_T; 6] = seq
                    .next_element::<Vec<DW_CoreSubsys_m1hp_cpp_f_T>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(6, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let CoreSubsys: [DW_CoreSubsys_m1hp_cpp_T; 6] = seq
                    .next_element::<Vec<DW_CoreSubsys_m1hp_cpp_T>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(12, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let Add: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(18, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let Sub: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(24, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let ImpAsg_InsertedFor_a_l_at_inpor: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(30, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let ImpAsg_InsertedFor_multi_ax_acc: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(36, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let TmpLatchAtTriggeredSubsystemInp: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(42, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let TmpLatchAtTriggeredSubsystemI_e: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(48, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let IndexVector = seq
                    .next_element::<uint32_T>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(54, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let IndexVector1 = seq
                    .next_element::<uint32_T>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(55, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let IndexVector2 = seq
                    .next_element::<uint32_T>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(56, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let Dk_merge = seq
                    .next_element::<uint32_T>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(57, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let UnitDelay_DSTATE = seq
                    .next_element::<uint32_T>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(58, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let ResettableDelay_DSTATE = seq
                    .next_element::<uint32_T>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(59, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let Compare: [boolean_T; 6] = seq
                    .next_element::<Vec<boolean_T>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(60, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(DW_m1hp_cpp_T {
                    CoreSubsys_pn,
                    CoreSubsys_p,
                    CoreSubsys,
                    Add,
                    Sub,
                    ImpAsg_InsertedFor_a_l_at_inpor,
                    ImpAsg_InsertedFor_multi_ax_acc,
                    TmpLatchAtTriggeredSubsystemInp,
                    TmpLatchAtTriggeredSubsystemI_e,
                    IndexVector,
                    IndexVector1,
                    IndexVector2,
                    Dk_merge,
                    UnitDelay_DSTATE,
                    ResettableDelay_DSTATE,
                    Compare,
                })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut CoreSubsys_pn = None;
                let mut CoreSubsys_p = None;
                let mut CoreSubsys = None;
                let mut Add = None;
                let mut Sub = None;
                let mut ImpAsg_InsertedFor_a_l_at_inpor = None;
                let mut ImpAsg_InsertedFor_multi_ax_acc = None;
                let mut TmpLatchAtTriggeredSubsystemInp = None;
                let mut TmpLatchAtTriggeredSubsystemI_e = None;
                let mut IndexVector = None;
                let mut IndexVector1 = None;
                let mut IndexVector2 = None;
                let mut Dk_merge = None;
                let mut UnitDelay_DSTATE = None;
                let mut ResettableDelay_DSTATE = None;
                let mut Compare = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::CoreSubsys_pn => {
                            if CoreSubsys_pn.is_some() {
                                return Err(::serde::de::Error::duplicate_field("CoreSubsys_pn"));
                            }
                            CoreSubsys_pn =
                                Some(map.next_value::<Vec<DW_CoreSubsys_m1hp_cpp_fw_T>>()?);
                        }

                        Field::CoreSubsys_p => {
                            if CoreSubsys_p.is_some() {
                                return Err(::serde::de::Error::duplicate_field("CoreSubsys_p"));
                            }
                            CoreSubsys_p =
                                Some(map.next_value::<Vec<DW_CoreSubsys_m1hp_cpp_f_T>>()?);
                        }

                        Field::CoreSubsys => {
                            if CoreSubsys.is_some() {
                                return Err(::serde::de::Error::duplicate_field("CoreSubsys"));
                            }
                            CoreSubsys = Some(map.next_value::<Vec<DW_CoreSubsys_m1hp_cpp_T>>()?);
                        }

                        Field::Add => {
                            if Add.is_some() {
                                return Err(::serde::de::Error::duplicate_field("Add"));
                            }
                            Add = Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::Sub => {
                            if Sub.is_some() {
                                return Err(::serde::de::Error::duplicate_field("Sub"));
                            }
                            Sub = Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::ImpAsg_InsertedFor_a_l_at_inpor => {
                            if ImpAsg_InsertedFor_a_l_at_inpor.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "ImpAsg_InsertedFor_a_l_at_inpor",
                                ));
                            }
                            ImpAsg_InsertedFor_a_l_at_inpor =
                                Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::ImpAsg_InsertedFor_multi_ax_acc => {
                            if ImpAsg_InsertedFor_multi_ax_acc.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "ImpAsg_InsertedFor_multi_ax_acc",
                                ));
                            }
                            ImpAsg_InsertedFor_multi_ax_acc =
                                Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::TmpLatchAtTriggeredSubsystemInp => {
                            if TmpLatchAtTriggeredSubsystemInp.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "TmpLatchAtTriggeredSubsystemInp",
                                ));
                            }
                            TmpLatchAtTriggeredSubsystemInp =
                                Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::TmpLatchAtTriggeredSubsystemI_e => {
                            if TmpLatchAtTriggeredSubsystemI_e.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "TmpLatchAtTriggeredSubsystemI_e",
                                ));
                            }
                            TmpLatchAtTriggeredSubsystemI_e =
                                Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::IndexVector => {
                            if IndexVector.is_some() {
                                return Err(::serde::de::Error::duplicate_field("IndexVector"));
                            }
                            IndexVector = Some(map.next_value::<uint32_T>()?);
                        }

                        Field::IndexVector1 => {
                            if IndexVector1.is_some() {
                                return Err(::serde::de::Error::duplicate_field("IndexVector1"));
                            }
                            IndexVector1 = Some(map.next_value::<uint32_T>()?);
                        }

                        Field::IndexVector2 => {
                            if IndexVector2.is_some() {
                                return Err(::serde::de::Error::duplicate_field("IndexVector2"));
                            }
                            IndexVector2 = Some(map.next_value::<uint32_T>()?);
                        }

                        Field::Dk_merge => {
                            if Dk_merge.is_some() {
                                return Err(::serde::de::Error::duplicate_field("Dk_merge"));
                            }
                            Dk_merge = Some(map.next_value::<uint32_T>()?);
                        }

                        Field::UnitDelay_DSTATE => {
                            if UnitDelay_DSTATE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "UnitDelay_DSTATE",
                                ));
                            }
                            UnitDelay_DSTATE = Some(map.next_value::<uint32_T>()?);
                        }

                        Field::ResettableDelay_DSTATE => {
                            if ResettableDelay_DSTATE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "ResettableDelay_DSTATE",
                                ));
                            }
                            ResettableDelay_DSTATE = Some(map.next_value::<uint32_T>()?);
                        }

                        Field::Compare => {
                            if Compare.is_some() {
                                return Err(::serde::de::Error::duplicate_field("Compare"));
                            }
                            Compare = Some(map.next_value::<Vec<boolean_T>>()?);
                        }
                    }
                }

                let CoreSubsys_pn: [DW_CoreSubsys_m1hp_cpp_fw_T; 6] = CoreSubsys_pn
                    .ok_or_else(|| ::serde::de::Error::missing_field("CoreSubsys_pn"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let CoreSubsys_p: [DW_CoreSubsys_m1hp_cpp_f_T; 6] = CoreSubsys_p
                    .ok_or_else(|| ::serde::de::Error::missing_field("CoreSubsys_p"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let CoreSubsys: [DW_CoreSubsys_m1hp_cpp_T; 6] = CoreSubsys
                    .ok_or_else(|| ::serde::de::Error::missing_field("CoreSubsys"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let Add: [f64; 6] = Add
                    .ok_or_else(|| ::serde::de::Error::missing_field("Add"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let Sub: [f64; 6] = Sub
                    .ok_or_else(|| ::serde::de::Error::missing_field("Sub"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let ImpAsg_InsertedFor_a_l_at_inpor: [f64; 6] = ImpAsg_InsertedFor_a_l_at_inpor
                    .ok_or_else(|| {
                        ::serde::de::Error::missing_field("ImpAsg_InsertedFor_a_l_at_inpor")
                    })?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let ImpAsg_InsertedFor_multi_ax_acc: [f64; 6] = ImpAsg_InsertedFor_multi_ax_acc
                    .ok_or_else(|| {
                        ::serde::de::Error::missing_field("ImpAsg_InsertedFor_multi_ax_acc")
                    })?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let TmpLatchAtTriggeredSubsystemInp: [f64; 6] = TmpLatchAtTriggeredSubsystemInp
                    .ok_or_else(|| {
                        ::serde::de::Error::missing_field("TmpLatchAtTriggeredSubsystemInp")
                    })?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let TmpLatchAtTriggeredSubsystemI_e: [f64; 6] = TmpLatchAtTriggeredSubsystemI_e
                    .ok_or_else(|| {
                        ::serde::de::Error::missing_field("TmpLatchAtTriggeredSubsystemI_e")
                    })?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let IndexVector =
                    IndexVector.ok_or_else(|| ::serde::de::Error::missing_field("IndexVector"))?;

                let IndexVector1 = IndexVector1
                    .ok_or_else(|| ::serde::de::Error::missing_field("IndexVector1"))?;

                let IndexVector2 = IndexVector2
                    .ok_or_else(|| ::serde::de::Error::missing_field("IndexVector2"))?;

                let Dk_merge =
                    Dk_merge.ok_or_else(|| ::serde::de::Error::missing_field("Dk_merge"))?;

                let UnitDelay_DSTATE = UnitDelay_DSTATE
                    .ok_or_else(|| ::serde::de::Error::missing_field("UnitDelay_DSTATE"))?;

                let ResettableDelay_DSTATE = ResettableDelay_DSTATE
                    .ok_or_else(|| ::serde::de::Error::missing_field("ResettableDelay_DSTATE"))?;

                let Compare: [boolean_T; 6] = Compare
                    .ok_or_else(|| ::serde::de::Error::missing_field("Compare"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(DW_m1hp_cpp_T {
                    CoreSubsys_pn,
                    CoreSubsys_p,
                    CoreSubsys,
                    Add,
                    Sub,
                    ImpAsg_InsertedFor_a_l_at_inpor,
                    ImpAsg_InsertedFor_multi_ax_acc,
                    TmpLatchAtTriggeredSubsystemInp,
                    TmpLatchAtTriggeredSubsystemI_e,
                    IndexVector,
                    IndexVector1,
                    IndexVector2,
                    Dk_merge,
                    UnitDelay_DSTATE,
                    ResettableDelay_DSTATE,
                    Compare,
                })
            }
        }
        deserializer.deserialize_struct("DW_m1hp_cpp_T", FIELDS, SimulinkVisitor)
    }
}

impl ::serde::ser::Serialize for PrevZCX_m1hp_cpp_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("PrevZCX_m1hp_cpp_T", 3)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "ResettableDelay_Reset_ZCE",
            &self.ResettableDelay_Reset_ZCE,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "TriggeredSubsystem_Trig_ZCE",
            &self.TriggeredSubsystem_Trig_ZCE,
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "CoreSubsys_pn",
            &Vec::from(&self.CoreSubsys_pn),
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PrevZCX_m1hp_cpp_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &[
            "ResettableDelay_Reset_ZCE",
            "TriggeredSubsystem_Trig_ZCE",
            "CoreSubsys_pn",
        ];

        enum Field {
            ResettableDelay_Reset_ZCE,
            TriggeredSubsystem_Trig_ZCE,
            CoreSubsys_pn,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "ResettableDelay_Reset_ZCE" => Ok(Field::ResettableDelay_Reset_ZCE),
                            "TriggeredSubsystem_Trig_ZCE" => Ok(Field::TriggeredSubsystem_Trig_ZCE),
                            "CoreSubsys_pn" => Ok(Field::CoreSubsys_pn),
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = PrevZCX_m1hp_cpp_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrevZCX_m1hp_cpp_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let ResettableDelay_Reset_ZCE = seq
                    .next_element::<ZCSigState>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let TriggeredSubsystem_Trig_ZCE = seq
                    .next_element::<ZCSigState>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(1, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let CoreSubsys_pn: [ZCE_CoreSubsys_m1hp_cpp_fe_T; 6] = seq
                    .next_element::<Vec<ZCE_CoreSubsys_m1hp_cpp_fe_T>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(2, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(PrevZCX_m1hp_cpp_T {
                    ResettableDelay_Reset_ZCE,
                    TriggeredSubsystem_Trig_ZCE,
                    CoreSubsys_pn,
                })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut ResettableDelay_Reset_ZCE = None;
                let mut TriggeredSubsystem_Trig_ZCE = None;
                let mut CoreSubsys_pn = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::ResettableDelay_Reset_ZCE => {
                            if ResettableDelay_Reset_ZCE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "ResettableDelay_Reset_ZCE",
                                ));
                            }
                            ResettableDelay_Reset_ZCE = Some(map.next_value::<ZCSigState>()?);
                        }

                        Field::TriggeredSubsystem_Trig_ZCE => {
                            if TriggeredSubsystem_Trig_ZCE.is_some() {
                                return Err(::serde::de::Error::duplicate_field(
                                    "TriggeredSubsystem_Trig_ZCE",
                                ));
                            }
                            TriggeredSubsystem_Trig_ZCE = Some(map.next_value::<ZCSigState>()?);
                        }

                        Field::CoreSubsys_pn => {
                            if CoreSubsys_pn.is_some() {
                                return Err(::serde::de::Error::duplicate_field("CoreSubsys_pn"));
                            }
                            CoreSubsys_pn =
                                Some(map.next_value::<Vec<ZCE_CoreSubsys_m1hp_cpp_fe_T>>()?);
                        }
                    }
                }

                let ResettableDelay_Reset_ZCE = ResettableDelay_Reset_ZCE.ok_or_else(|| {
                    ::serde::de::Error::missing_field("ResettableDelay_Reset_ZCE")
                })?;

                let TriggeredSubsystem_Trig_ZCE = TriggeredSubsystem_Trig_ZCE.ok_or_else(|| {
                    ::serde::de::Error::missing_field("TriggeredSubsystem_Trig_ZCE")
                })?;

                let CoreSubsys_pn: [ZCE_CoreSubsys_m1hp_cpp_fe_T; 6] = CoreSubsys_pn
                    .ok_or_else(|| ::serde::de::Error::missing_field("CoreSubsys_pn"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(PrevZCX_m1hp_cpp_T {
                    ResettableDelay_Reset_ZCE,
                    TriggeredSubsystem_Trig_ZCE,
                    CoreSubsys_pn,
                })
            }
        }
        deserializer.deserialize_struct("PrevZCX_m1hp_cpp_T", FIELDS, SimulinkVisitor)
    }
}

impl ::serde::ser::Serialize for ExtU_m1hp_cpp_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("ExtU_m1hp_cpp_T", 2)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "x_target",
            &Vec::from(&self.x_target),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "v_target",
            &Vec::from(&self.v_target),
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExtU_m1hp_cpp_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &["x_target", "v_target"];

        enum Field {
            x_target,
            v_target,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "x_target" => Ok(Field::x_target),
                            "v_target" => Ok(Field::v_target),
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = ExtU_m1hp_cpp_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtU_m1hp_cpp_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let x_target: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let v_target: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(6, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(ExtU_m1hp_cpp_T { x_target, v_target })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut x_target = None;
                let mut v_target = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::x_target => {
                            if x_target.is_some() {
                                return Err(::serde::de::Error::duplicate_field("x_target"));
                            }
                            x_target = Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::v_target => {
                            if v_target.is_some() {
                                return Err(::serde::de::Error::duplicate_field("v_target"));
                            }
                            v_target = Some(map.next_value::<Vec<real_T>>()?);
                        }
                    }
                }

                let x_target: [f64; 6] = x_target
                    .ok_or_else(|| ::serde::de::Error::missing_field("x_target"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let v_target: [f64; 6] = v_target
                    .ok_or_else(|| ::serde::de::Error::missing_field("v_target"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(ExtU_m1hp_cpp_T { x_target, v_target })
            }
        }
        deserializer.deserialize_struct("ExtU_m1hp_cpp_T", FIELDS, SimulinkVisitor)
    }
}

impl ::serde::ser::Serialize for ExtY_m1hp_cpp_T {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ::serde::ser::Serializer,
    {
        let mut serde_state = serializer.serialize_struct("ExtY_m1hp_cpp_T", 3)?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "pos_d",
            &Vec::from(&self.pos_d),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "vel_d",
            &Vec::from(&self.vel_d),
        )?;

        ::serde::ser::SerializeStruct::serialize_field(
            &mut serde_state,
            "acc_d",
            &Vec::from(&self.acc_d),
        )?;

        ::serde::ser::SerializeStruct::end(serde_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExtY_m1hp_cpp_T {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: ::serde::de::Deserializer<'de>,
    {
        const FIELDS: &'static [&'static str] = &["pos_d", "vel_d", "acc_d"];

        enum Field {
            pos_d,
            vel_d,
            acc_d,
        }

        impl<'de> ::serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                struct FieldVisitor;
                impl<'de> ::serde::de::Visitor<'de> for FieldVisitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("field identifier")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: ::serde::de::Error,
                    {
                        match value {
                            "pos_d" => Ok(Field::pos_d),
                            "vel_d" => Ok(Field::vel_d),
                            "acc_d" => Ok(Field::acc_d),
                            _ => Err(::serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct SimulinkVisitor;
        impl<'de> ::serde::de::Visitor<'de> for SimulinkVisitor {
            type Value = ExtY_m1hp_cpp_T;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtY_m1hp_cpp_T")
            }
            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
            where
                V: ::serde::de::SeqAccess<'de>,
            {
                let pos_d: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(0, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let vel_d: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(6, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let acc_d: [f64; 6] = seq
                    .next_element::<Vec<f64>>()?
                    .ok_or_else(|| ::serde::de::Error::invalid_length(12, &self))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(ExtY_m1hp_cpp_T {
                    pos_d,
                    vel_d,
                    acc_d,
                })
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                let mut pos_d = None;
                let mut vel_d = None;
                let mut acc_d = None;
                while let Some(key) = map.next_key::<Field>()? {
                    match key {
                        Field::pos_d => {
                            if pos_d.is_some() {
                                return Err(::serde::de::Error::duplicate_field("pos_d"));
                            }
                            pos_d = Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::vel_d => {
                            if vel_d.is_some() {
                                return Err(::serde::de::Error::duplicate_field("vel_d"));
                            }
                            vel_d = Some(map.next_value::<Vec<real_T>>()?);
                        }

                        Field::acc_d => {
                            if acc_d.is_some() {
                                return Err(::serde::de::Error::duplicate_field("acc_d"));
                            }
                            acc_d = Some(map.next_value::<Vec<real_T>>()?);
                        }
                    }
                }

                let pos_d: [f64; 6] = pos_d
                    .ok_or_else(|| ::serde::de::Error::missing_field("pos_d"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let vel_d: [f64; 6] = vel_d
                    .ok_or_else(|| ::serde::de::Error::missing_field("vel_d"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                let acc_d: [f64; 6] = acc_d
                    .ok_or_else(|| ::serde::de::Error::missing_field("acc_d"))?
                    .try_into()
                    .map_err(|_| {
                        ::serde::de::Error::invalid_value(::serde::de::Unexpected::Seq, &self)
                    })?;

                Ok(ExtY_m1hp_cpp_T {
                    pos_d,
                    vel_d,
                    acc_d,
                })
            }
        }
        deserializer.deserialize_struct("ExtY_m1hp_cpp_T", FIELDS, SimulinkVisitor)
    }
}

#[derive(Clone, Copy, Debug, Default, ::serde::Serialize, ::serde::Deserialize)]
pub struct RealTimeData {
    prevZCSigState: PrevZCX_m1hp_cpp_T,
    dwork: DW_m1hp_cpp_T,
}
impl RealTimeData {
    pub fn as_mut(&mut self) -> tag_RTM_m1hp_cpp_T {
        tag_RTM_m1hp_cpp_T {
            prevZCSigState: &mut self.prevZCSigState as *mut _,
            dwork: &mut self.dwork as *mut _,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use matio_rs::MatFile;
    #[test]
    fn step() {
        // let mat = MatFile::load("hp_dyn_step_test.mat").unwrap();
        // let hp_dyn_step_t: Vec<f64> = mat.var("hp_dyn_step_t").unwrap();
        // let hp_dyn_step_y: Vec<f64> = mat.var("hp_dyn_step_y").unwrap();

        let mut ctrl = HardpointsPreprocessor::new(100_u32);
        // ctrl.inputs.In1.iter_mut().for_each(|x| *x = 1f64);
        // let mut y = vec![];
        // for _ in &hp_dyn_step_t {
        //     ctrl.step();
        //     y.extend_from_slice(ctrl.outputs.Out1.as_slice());
        // }

        // // dbg!(&y[y.len() - 6..]);

        // let y_err = (y
        //     .chunks(6)
        //     .take(6 * 5)
        //     .zip(&hp_dyn_step_y)
        //     .map(|(y, y0)| y.iter().map(|y| *y - *y0).map(|x| x * x).sum::<f64>())
        //     .sum::<f64>()
        //     / y.len() as f64)
        //     .sqrt();
        // dbg!(y_err);
    }
}
